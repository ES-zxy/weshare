<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二分法及其应用 · WeShare</title><meta name="description" content="二分法及其应用 - imuxin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/weshare/weshare.png"><link rel="stylesheet" href="/weshare/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.slicloud.com:38876/atom.xml" title="WeShare"></head><body><div class="wrap"><header><a href="/weshare/" class="logo-link"><img src="/weshare/weshare.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/weshare/" target="_self" class="nav-list-link">ARTICLES</a></li><li class="nav-list-item"><a href="/weshare/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/iweshare/weshare" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/weshare/2019/09/15/About/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">二分法及其应用</h1><div class="post-info">muxin @Feb 20, 2020</div><div class="post-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-sample"><span class="toc-text">A sample</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Definition"><span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Application-scene"><span class="toc-text">Application scene</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-search"><span class="toc-text">Binary search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-insertion-sort"><span class="toc-text">Binary insertion sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-merge-sort"><span class="toc-text">Binary merge sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-find-the-middle-element-of-a-linked-list"><span class="toc-text">How to find the middle element of a linked list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-bisect"><span class="toc-text">git bisect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div><div class="post-content"><h2 id="A-sample"><a href="#A-sample" class="headerlink" title="A sample"></a>A sample</h2><p>在聚餐的酒席上，我们经常会玩一个游戏，随机一人写下0到100间的一个数字N，其他人轮流报一个数字，让区间逐步逼近数字N，直到叫到N的人喝酒。其中会有人去中间数字快速缩小范围。</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>对于区间[a，b]上连续不断且f（a）·f（b）&lt;0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。</p>
<a id="more"></a>
<p><img src="bisection_method.png" alt="Bisection_method"></p>
<h2 id="Application-scene"><a href="#Application-scene" class="headerlink" title="Application scene"></a>Application scene</h2><h3 id="Binary-search"><a href="#Binary-search" class="headerlink" title="Binary search"></a>Binary search</h3><ul>
<li><p>Description:<br>  将n个元素的单调数列，二等分两个区间，剔除没有目标元素的区间，继续等分区间查找，直到锁定目标元素或者区间不能再划分。</p>
</li>
<li><p>Algorithm:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arr, start, end, key)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'NotFound: %s'</span> % key)</span><br><span class="line">    mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; key:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, start, mid<span class="number">-1</span>, key)</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &lt; key:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, mid+<span class="number">1</span>, end, key)</span><br><span class="line">    <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>
</li>
<li><p>Conclusion:</p>
</li>
</ul>
<h3 id="Binary-insertion-sort"><a href="#Binary-insertion-sort" class="headerlink" title="Binary insertion sort"></a>Binary insertion sort</h3><ul>
<li><p>Description:<br> Insert sort: 将n个元素的数列分为已有序和无序两个部分，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前<code>逐个</code>进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。<br> Binary insertion sort: 将n个元素的数列分为已有序和无序两个部分，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前<code>二分</code>进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。</p>
</li>
<li><p>Algorithm:<br><img src="sort-insert-01.gif" alt="insertion sort"></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(collection, key)</span>:</span></span><br><span class="line">    <span class="string">"""Pure implementation of the binary search algorithm in Python.</span></span><br><span class="line"><span class="string">    :param collection: some mutable ordered collection with heterogeneous</span></span><br><span class="line"><span class="string">    :param key: the search keyword</span></span><br><span class="line"><span class="string">    :return: the replace address</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__binary_search__</span><span class="params">(collection, start, end, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> collection[mid] &gt; key:</span><br><span class="line">            <span class="keyword">return</span> __binary_search__(collection, start, mid<span class="number">-1</span>, key)</span><br><span class="line">        <span class="keyword">if</span> collection[mid] &lt; key:</span><br><span class="line">            <span class="keyword">return</span> __binary_search__(collection, mid+<span class="number">1</span>, end, key)</span><br><span class="line">        <span class="keyword">return</span> mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> __binary_search__(collection, <span class="number">0</span>, len(collection)<span class="number">-1</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_insertion_sort</span><span class="params">(collection)</span>:</span></span><br><span class="line">    <span class="string">"""Pure implementation of the binary insertion sort algorithm in Python.</span></span><br><span class="line"><span class="string">    :param collection: some mutable ordered collection with heterogeneous</span></span><br><span class="line"><span class="string">    :return: the same collection ordered by ascending</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; binary_insertion_sort([0, 5, 3, 2, 2])</span></span><br><span class="line"><span class="string">    [0, 2, 2, 3, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; binary_insertion_sort([])</span></span><br><span class="line"><span class="string">    []</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; binary_insertion_sort([-2, -5, -45])</span></span><br><span class="line"><span class="string">    [-45, -5, -2]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> loop_index <span class="keyword">in</span> range(<span class="number">1</span>, len(collection)):</span><br><span class="line">        insert_point = binary_search(collection[<span class="number">0</span>:loop_index], collection[loop_index])</span><br><span class="line">        <span class="keyword">if</span> insert_point == loop_index:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        collection = (collection[<span class="number">0</span>:insert_point]</span><br><span class="line">            + [collection[loop_index]]</span><br><span class="line">            + collection[insert_point:loop_index]</span><br><span class="line">            + collection[loop_index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> collection</span><br></pre></td></tr></table></figure>
</li>
<li><p>Conclusion:</p>
</li>
</ul>
<h3 id="Binary-merge-sort"><a href="#Binary-merge-sort" class="headerlink" title="Binary merge sort"></a>Binary merge sort</h3><ul>
<li><p>Description:<br>  选择中间的数，把数组对半划分。分别对<code>子问题a</code>和<code>子问题b</code>进行排序，最后把这两个排好序的问题综合到一个问题。</p>
</li>
<li><p>Algorithm:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(collection)</span>:</span></span><br><span class="line">    <span class="string">"""Pure implementation of the merge sort algorithm in Python</span></span><br><span class="line"><span class="string">    :param collection: some mutable ordered collection with heterogeneous</span></span><br><span class="line"><span class="string">    comparable items inside</span></span><br><span class="line"><span class="string">    :return: the same collection ordered by ascending</span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; merge_sort([0, 5, 3, 2, 2])</span></span><br><span class="line"><span class="string">    [0, 2, 2, 3, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; merge_sort([])</span></span><br><span class="line"><span class="string">    []</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; merge_sort([-2, -5, -45])</span></span><br><span class="line"><span class="string">    [-45, -5, -2]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="string">"""merge left and right</span></span><br><span class="line"><span class="string">        :param left: left collection</span></span><br><span class="line"><span class="string">        :param right: right collection</span></span><br><span class="line"><span class="string">        :return: merge result</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            result.append((left <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] <span class="keyword">else</span> right).pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> result + left + right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(collection) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> collection</span><br><span class="line">    mid = len(collection) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(collection[:mid]), merge_sort(collection[mid:]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Conclusion:</p>
</li>
</ul>
<h3 id="How-to-find-the-middle-element-of-a-linked-list"><a href="#How-to-find-the-middle-element-of-a-linked-list" class="headerlink" title="How to find the middle element of a linked list"></a>How to find the middle element of a linked list</h3><ul>
<li><p>Description:<br>  现有一个不知长度的链表，如何找到中间结点。</p>
</li>
<li><p>Algorithm:</p>
</li>
</ul>
<h3 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h3><ul>
<li><p>Description:<br>  Use binary search to find the commit that introduced a bug.</p>
<p>  This command uses a binary search algorithm to find which commit in your project’s history introduced a bug. You use it by first telling it a “bad” commit that is known to contain the bug, and a “good” commit that is known to be before the bug was introduced. Then git bisect picks a commit between those two endpoints and asks you whether the selected commit is “good” or “bad”. It continues narrowing down the range until it finds the exact commit that introduced the change.</p>
<p>  In fact, git bisect can be used to find the commit that changed any property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark’s performance to improve. To support this more general usage, the terms “old” and “new” can be used in place of “good” and “bad”, or you can choose your own terms. See section “Alternate terms” below for more information.</p>
</li>
<li><p>Usages:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git bisect</span><br><span class="line">    start  <span class="comment"># to start our bug or fix binary search session</span></span><br><span class="line">    bad  <span class="comment"># to claim the bad commit end</span></span><br><span class="line">    good  <span class="comment"># to claim the good commit start</span></span><br><span class="line">    reset  <span class="comment"># to reset search session</span></span><br><span class="line"></span><br><span class="line">    ...  <span class="comment"># use `git bisect --help` to find more details</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>An example:<br>  现有一个如下 <code>git log</code> 的示例项目，假设项目中出现 <code>bug</code> 字符串的是有问题的，利用 <code>git bisect</code> 找到是哪个提交导致的这个问题的。<br>  <img src="git-bisect-sample-project.png" alt="sample project git log"></p>
<p>  查找流程：<br>  <img src="git-bisect-operations.png" alt="git bisect operations"></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Bisection_method" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bisection_method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></li>
<li><a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">https://github.com/TheAlgorithms/Python</a></li>
<li><a href="https://zh.wikipedia.org/wiki/二分搜尋演算法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/二分搜尋演算法</a></li>
<li><a href="https://baroni.tech/blog/git-bisect/" target="_blank" rel="noopener">https://baroni.tech/blog/git-bisect/</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/weshare/2019/09/30/How_to_Setup_OpenVPN_on_the_iPhone/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://www.slicloud.com:38876">imuxin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script><script src="/weshare/js/post.js"></script></body></html>