title: Byzantine Generals Problem
author: zxy
tags:
  - DISTRIBUTED
  - ALGORITHM
  - CONSENSUS MECHANISM
categories:
  - Algorithm
date: 2020-03-12 13:24:00
---
# 拜占庭将军问题

## 背景信息

> **维基百科**
>
> 拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。
>
> 在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。
>
> 拜占庭将军问题被认为是容错性问题中最难的问题类型之一。

## 问题描述

莱斯利·兰波特在其论文中描述了如下问题：

> 一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。

拜占庭将军问题是一个共识问题。应该明确的是，拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，我们已经假定了信道是没有问题的，并在这个前提下，去做一致性和容错性相关研究。如果需要考虑信道是有问题的，这涉及到了另一个相关问题：两军问题。

至此，我们将拜占庭将军问题简化成了，所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动；而形式化的要求就是，"一致性"与"正确性"。

## Raft协议

在系统不同的机器之间会传递错误的消息，这种情况即为拜占庭问题。这与”网络分割、机器崩溃...”是不同的。比如Raft协议不能容忍拜占庭问题，但是能够在非拜占庭错误情况下，有网络延迟、分区、丢包、冗余和乱序等错误情况出现时，都可以保证其操作的正确性。

**Raft Leader选举**

![image-20200313160411741](../Byzantine_Generals_Problem/image-20200313160411741.png)

Raft采用心跳机制触发Leader选举。当系统启动时，所有节点初始化为Follower状态，设置任期为0，并启动计时器，计时器超时后，Follower节点转化为Candidate节点，一旦转化为Candidate节点，立即开始一下几件事情：

1、增加自己的任期数

2、启动一个新的计时器

3、给自己投一票

4、向所有其他节点发送RequestVote RPC请求，并等待其他节点回复。

如果在计时器超时前接收到多数节点的同意投票，则转换为Leader；如果接受到其他节点的AppendEntries心跳RPC，说明其他节点已经被选为Leader，则转换为Follower；如果计时器超时时还没有接受到以上两种信息中的任何一种，则重复步骤1-4，进行新的选举。

每个Follower在一个任期内只能投一票，采取先到先得的策略。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC，则转换为Candidate，开始请求投票。也就是在当期Leader Down掉后，就会有Follower开始转换为Candidate开始投票。

如果多个节点同时发起投票，每个节点都没有拿到多数票（这种情况成为Split Vote），则增加任期数，在新的任期内重新进行投票。

## BFT协议

无论是 Paxos 还是 Raft 都只能解决非拜占庭将军容错的一致性问题（CFT，Crash Fault Tolerance），不能够应对“故意的发送错误信息”问题。

接下来我们分析一下BFT（Byzantine Fault Tolerance）伪造信息的拜占庭错误。常见的有工作量证明（PoW）、权益证明（PoS）、委托权益证明（DPoS），这些算法在区块链得到广泛应用。

拜占庭问题，关键要达到下面两个目标：

**IC1：**所有忠诚的副官遵守一个命令，即一致性。

**IC2：**若司令是忠诚的，每一个忠诚的副官遵守他发出的命令，即正确性。

在经典的情形下，我们可以找到两种办法，`口头协议`和`书面协议`。下面将会逐一探讨两种算法的推演和证明，其中证明部分并不会采用纯推理，而以介绍证明思路为主。

**口头协议**

首先，我们明确什么是口头协议。我们将满足以下三个条件的方式称为口头协议：

**A1**：每个被发送的消息都能够被正确的投递

**A2**：信息接收者知道是谁发送的消息

**A3**：能够知道缺少的消息

采用口头协议，若叛徒数少于1/3，则拜占庭将军问题可解。也就是说，若叛徒数为m，当将军总数n至少为3m+1时，问题可解（即满足了IC1和IC2）。

![image-20200313172459681](../Byzantine_Generals_Problem/image-20200313172459681.png)

倘若司令在OM(1)中给各副官发送的消息都是进攻（A），之后OM(0)时，叛徒副官3给副官1和副官2说他收到的消息是撤退（R）。

那么对于副官1（或副官2）来说，他综合司令、副官3和副官2（或副官1）后得到的消息向量都将会是(A,A,R)，利用majority函数之后，将会采用A，满足了IC1和IC2（回顾IC1：所有忠诚的副官遵守一个命令，IC2：若司令是忠诚的，每一个忠诚的副官遵守他发出的命令）。

![image-20200313173028273](../Byzantine_Generals_Problem/image-20200313173028273.png)

倘若司令是叛徒，那么我们已经不需要满足IC2。为方便，我们假设叛徒司令在OM(1)会给三个副官发送的信息是(x,y,z)，其中x，y，z都可以是A或R的任意一种。之后，三位忠诚的副官将会按照OM(0)要求的那样，交换他们收到的信息。

对于副官1，他综合司令、副官2和副官3后得到的消息向量将会是(x,y,z)，可以发现对于其他两个忠实的副官，他们得到的消息向量也将是(x,y,z)。不管x，y，z如何变化，majority(x,y,z)对于三人来说都是一样的，所以三个副官将会采用一致的行动。

**书面协议**

除了A1，A2和A3以外，我们在口头协议之上添加一个条件A4，使之成为书面协议

**A4**：（a）签名不可伪造，一旦被篡改即可发现，而叛徒的签名可被其他叛徒伪造；（b）任何人都可以验证签名的可靠性。

举个例子，n=3，m=1，其中司令是叛徒，这是口头协议不能解决的状况。

![image-20200313173428657](../Byzantine_Generals_Problem/image-20200313173428657.png)

很显然，副官1得到的V1={A,R}，副官2得到相同的V2={A,R}。他们采用choice函数后得到的命令一定相同。

**总结**

书面协议的结论非常令人兴奋，这不是解决了拜占庭将军问题了吗？但请注意我们在A1\~A4中实际上是添加了一些条件的，这使得拜占庭将军问题在这些假设下能够解决，但是在实际状况中却会有一些问题。观察A1\~A4，我们做了一些在现实中比较难以完成的假设，比如没考虑传输信息的延迟时间，书面协议的签名体系难以实现，而且签名消息记录的保存难以摆脱一个中心化机构而独立存在。

回顾A1-A4：

**A1**：每个被发送的消息都能够被正确的投递

**A2**：信息接收者知道是谁发送的消息

**A3**：能够知道缺少的消息

**A4**：（a）签名不可伪造，一旦被篡改即可发现，而叛徒的签名可被其他叛徒伪造；（b）任何人都可以验证签名的可靠性。

##区块链

在比特币系统中每时每刻都会产生许多交易，这些交易一经产生就向全网广播，以保证每个节点都可以收到，但它们并不是零乱地散落在系统中，而是每隔一段时间就会被打包成一个区块（Block）记录到比特币的总账里，将这些区块按时间顺序连接到一起就成了区块链（Blockchain），也就是说区块链一词其实有两层含义，它既是分布式系统中达成共识的技术，在比特币系统中也特指包含了所有交易的总账。

![image-20200313175025988](%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98.assets/image-20200313175025988.png)

这个目标是通过挖矿（Mining）来实现的。上面就是一个挖矿过程的示意图，图中每个横线代表一笔交易，矩形方框代表包含着许多交易的区块，连在一起就是总账。

挖矿过程是通过一个叫做SHA-256的函数实现的，它的功能是输入任意一个文件，返回一个毫无规律的64位16进制数，虚线部分就是每次挖矿时矿工（Miner）需要输入的内容，它由三部分组成：上一个区块的信息，新产生的交易和一个随机数。输入之后SHA-256会返回一个结果，最先得到足够小的64位数的节点会将自己的随机数和SHA-256的结果向全网广播以供其他人验证 。

目前这个“足够小”的要求是前17位数全是0， 难度会随着全网算力动态调整以保证约每10分钟产生一个新矿，增加0的个数可以直接调整难度和时间。验证过程就是其他矿工将收到的随机数输入到SHA-256中看能否得到相同的结果，若结果不同，说明发出广播的矿工的账本和大家不一样，有私自伪造和篡改交易的嫌疑，从而导致验证失败，这就保证了只有诚实节点才能挖到新矿。通过验证的节点成为新矿的矿主，它会将作为SHA-256输入内容的新交易打包成新的区块记录到总账中，其他节点也会照做。与此同时新矿主获得两笔奖励，一笔是新区块中所有交易的手续费；另外一笔是新发行的比特币，该数额每四年减半。每次挖矿结束之后，所有矿工一起投入到下一轮的挖矿比拼之中，每个人挖到矿的概率和自己为比特币系统贡献的算力成正比，总账就是依靠这样一个精巧而公平的挖矿机制不断延续下去的。

## 相关算法

1980年代被提出用来达到拜占庭容错的架构，如：FTMP、MMFCS 与 SIFT。

1999年，卡斯托（Miguel Castro）与李斯克夫（Barbara Liskov）提出了实用拜占庭容错（PBFT）演算法。该演算法能提供高效能的运算，使得系统可以每秒处理成千的请求，比起旧式系统快了一些。

而在PBFT之后，许多用于拜占庭容错（BFT）的通讯协议也被提出来改善其通讯的强健性与效率。比如Q/U、HQ、Zyzzyva与ABsTRACTs，用来提升效率。而Aardvark与RBFT是用来加强强健性。另外，Adapt则使用原有的BFT协议做调适，以强化其效率与强健性。BFT协议更可以借由加入可任务的单元，以减少发出副本的次数。比如：A2M-PBFT-EA与MinBFT。

在对等式数位货币系统比特币里，比特币网路的运作是平行的（parallel）。各节点与终端都运算著区块链来达成工作量证明（PoW）。

## Reference
[《In Search of an Understandable Consensus Algorithm (Extended Version)》](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf)
[拜占庭将军问题-维基百科](https://zh.wikipedia.org/zh-hans/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98)
[什么是拜占庭将军问题](https://learnblockchain.cn/2018/02/05/bitcoin-byzantine/)
[如何理解拜占庭将军问题](https://www.zhihu.com/question/23167269)
